<!--
title : CHAMPS Verbal Autopsy Data Quality Check [Part 1]
author : Young
date: Aug 23 2023
-->

# **CHAMPS Verbal Autopsy Data Quality Assessment Report**
###### **Yoonyoung Choi**
###### **Institute of Population Research, The Ohio State University**
###### **Aug 23 2023**

\
\

This report presents a data quality assessment of the dataset "CHAMPS Deidentified Verbal Autopsy Results." The objective is to identify and discuss data quality issues that may impact further data processing and analysis. This document is created using *Julia markdown* and is based on the **RDA database**[ver.Aug 2023].

\

<!-- NOT appeared this setup dependencies and datasetup -->
 ### Set up the dataset
```julia; echo=false; results="hidden"
using CSV
using DataFrames
using Pkg
using Dates
"FreqTables" ∉ keys(Pkg.project().dependencies) && Pkg.add("FreqTables")
"StatsBase" ∉ keys(Pkg.project().dependencies) && Pkg.add("StatsBase")
using FreqTables
using StatsBase
```
```julia
filename = "champs_df2"
path = "/Users/young/Documents/GitHub/RDAIngest.jl/"
file = joinpath(path, "$filename.csv")
champs_raw = CSV.File(file; delim=',', quotechar='"', dateformat="yyyy-mm-dd", decimal='.') |> DataFrame
```
\
\

### Dataset overview

#### Data Size
```julia 
size(champs_raw)
```

#### Data types 
```julia ; echo=false
column_types = Dict{Symbol, Type}()
for col in names(champs_raw)
    column_types[Symbol(col)] = eltype(champs_raw[!, col])
end

type_counts = Dict{Type, Int}()
for col_type in values(column_types)
    type_counts[col_type] = get(type_counts, col_type, 0) + 1
end

println("Summary of variable types:")
for (col_type, count) in type_counts
    println("$col_type: $count variables")
end
```
\
\

### Exploring Variable Types

#### 1) Missing Variables 
There are 89 variables that consist solely of missing values. Further investigation is needed to determine if these variables are as expected. 

The list of variables with only missing values is as follows:
```julia ; echo=false
println("Variables with type Missing:")
for col_name in names(champs_raw)
    if eltype(champs_raw[!, col_name]) == Missing
        println(col_name)
    end
end
```

\

##### 2) Categorical Variables (String)
- *Inconsistencies thoughout the categorical variables*

Categorical variables are primarily represented as strings. Some inconsistencies exist in the value types for each category, including mixed upper/lower case and "don't know" answers. 

Examples include:


- **Id10186**: At any time during the final illness was there blood in the stools?
```julia; echo=false
freqtable(champs_raw, :"Id10186")
```

- **Id10052**: What was her/his citizenship/nationality?
```julia; echo=false
freqtable(champs_raw, :"Id10052")
```
Addressing these irregularities is a straightforward task, involving a simple conversion to lowercase and a uniform adjustment of responses like 'doesn't know' and 'does not know' to the universally recognized abbreviation 'dk'. Additionally, enhancing consistency through the introduction of underscores for spaces between words can further refine the data quality.

\

##### 3) Numerical Variables (Integer/Float)
- *Calculating issues and data quality issues for Ages*

Numerical variables, such as calculated ages, have a significant number of missing values.

Examples include:
- **ageInDays**: Calculated: (${Id10023} - ${Id10021})
```julia
describe(champs_raw[!, :ageInDays])
```
- **ageInYears**: Calculated: int(${ageInDays} div 365.25)
```julia
describe(champs_raw[!, :ageInYears])
```
- **ageInYears2**: Calculated: int(${ageInMonthsByYear} div 12)
```julia
describe(champs_raw[!, :ageInYears2])
```
- **ageInYearsRemain**: Calculated: ${ageInDays} mod 365.25
```julia
describe(champs_raw[!, :ageInYearsRemain])
```
The range of *ageInYearsRemain* variable lacks logical coherence and warrants further examination.

\

#### 4) Date Variables
- *Validity issues with all the date variables* 

\

List of date variables
```julia; echo=false
date_union_vars = []
date_vars = []
for col_name in names(champs_raw)
    col_type = eltype(champs_raw[!, col_name])
    if col_type == Union{Missing, Date}
        push!(date_union_vars, col_name)
    elseif col_type == Date
        push!(date_vars, col_name)
    end
end

println("Variables of dates:")
for var in append!(date_union_vars, date_vars)
    println(var)
end
```
Examples include:
- **Id10012: Date of interview**
```julia ; echo=false
# Extract the "Id10012" date column
id10012_dates = champs_raw[!, :Id10012]
# Count missing values
id12_missing = count(ismissing, id10012_dates)
# Remove missing values
id12_dates = filter(x -> !ismissing(x), id10012_dates)

# Calculate the minimum and maximum valid dates
if !isempty(id12_dates)
    min_date = minimum(id12_dates)
    max_date = maximum(id12_dates)
    println("Range of valid dates for Id10012: $min_date to $max_date")
    println("Number of missing values: $id12_missing")
else
    println("No valid dates found.")
end
```

Source data for *ageInDays* Calculation : (${Id10023} - ${Id10021})

- **Id10021: Date of Birth**
```julia ; echo=false
# Extract the "Id10021" date column
id10021_dates = champs_raw[!, :Id10021]
# Count missing values
id21_missing = count(ismissing, id10021_dates)
# Remove missing values
id21_dates = filter(x -> !ismissing(x), id10021_dates)

# Calculate the minimum and maximum valid dates
if !isempty(id21_dates)
    min_date = minimum(id21_dates)
    max_date = maximum(id21_dates)
    println("Range of valid dates for Id10021: $min_date to $max_date")
    println("Number of missing values: $id21_missing")
else
    println("No valid dates found.")
end
```

- **Id10023: Date of Death**
```julia ; echo=false
# Extract the "Id10023" date column
id10023_dates = champs_raw[!, :Id10023]
# Count missing values
id23_missing = count(ismissing, id10023_dates)
# Remove missing values
id23_dates = filter(x -> !ismissing(x), id10023_dates)

# Calculate the minimum and maximum valid dates
if !isempty(id23_dates)
    min_date = minimum(id23_dates)
    max_date = maximum(id23_dates)
    println("Range of valid dates for Id10023: $min_date to $max_date")
    println("Number of missing values: $id23_missing")
else
    println("No valid dates found.")
end
```

Date variables exhibit validity issues that warrant further investigation. 

The presence of dates before the early 1900s and beyond 2022 in the dataset seems unusual and requires closer scrutiny.

\

#### 5) Time variables 
- *Inconsistent formatting issues* 

Time variables demonstrate inconsistencies in format. The variable *Id10011* presents challenges with its format and content. 

- Examples from **Id10011[Time at start of interview]** for different lengths are as follows:
```julia ; echo=false
# Extract the "Id10011" column
id10011_column = champs_raw[!, :Id10011]
# Count the number of missing values
id11_missing = count(ismissing, id10011_column)

# Get non-missing values
non_missing_values = id10011_column[.!ismissing.(id10011_column)]
# Create a dictionary to store examples by length
examples_by_length = Dict{Int, String}()

# Iterate through non-missing values
for value in non_missing_values
    length_value = length(value)
    if !haskey(examples_by_length, length_value)
        examples_by_length[length_value] = value
    end
end

# Print example values for different lengths
println("Example values from Id10011:")
for (length, example) in examples_by_length
    println("Length $length: $example")
end
```
\
\

### Conclusion
This data quality report provides a comprehensive overview of the CHAMPS VA dataset's characteristics and potential issues. 
It serves as a foundation for further data cleaning and analysis. Addressing these data quality concerns will be crucial to ensuring accurate and reliable results.
